# pydoc can write docs for all modules in a directory (or a module name),
# but doesn't like being given a path to any actual file.


# Using pydoc instead:
# html:
#	pydoc -w $(top_builddir)/glom/python_embed/python_module/.libs/
#	mkdir html
#	mv glom_1_14.html html/index.html

book_name = pyglom_$(GLOM_ABI_VERSION_UNDERLINED)

# The name of the sub-directory where the generated documentation
# will be placed.
doc_outdir ?= .

# Installation directories.
libdocdir    = $(datarootdir)/doc/$(book_name)
referencedir = $(libdocdir)/reference
htmlrefdir   = $(referencedir)/html

if ENABLE_DOCUMENTATION
doc_inst_targets = install-htmlref
doc_inst_files   =
doc_dist_files   = $(call vpath_listall,$(htmlref_patterns))
else
doc_inst_targets =
doc_inst_files   =
doc_dist_files   =
endif

dist_reference_DATA = $(strip $(doc_inst_files))
dist_noinst_DATA    = $(strip $(doc_dist_files))

#DISTCLEANFILES       = $(doc_outdir)/doxygen.log
MAINTAINERCLEANFILES = $(doc_outdir)/html/* outdir

html/index.html:
	rm -rf html
	$(SPHINX_BUILD) -b html ./ $(doc_outdir)/html/

# Explicitly depend on the files to be distributed or installed.
all-local: $(doc_inst_files) $(doc_dist_files)

# Hook up custom rules for translating references to external documentation
# to the actual location at install time.
install-data-local: $(doc_inst_targets)

# Hook up corresponding custom uninstall rules.
uninstall-local: $(addprefix un,$(doc_inst_targets))

# A list of wildcard patterns matching the files from the HTML directory
# generated by sphinx which should be distributed and installed.
htmlref_patterns ?= $(addprefix $(doc_outdir)/html/*.,css gif html png js inv txt)
htmlref_patterns_static ?= $(addprefix $(doc_outdir)/html/_static/*.,css gif html png js inv txt)

# Expand to a list of -name 'PATTERN' arguments for use with 'find'.
htmlref_find_patterns = $(patsubst %,-name '%' -o,$(notdir $(htmlref_patterns))) -false

# Helper variables to replicate each pattern with a $(srcdir)/ prefix.
# Also add quoting to prevent the shell from expanding the patterns.
htmlref_patterns_dup   = $(foreach item,$(htmlref_patterns),'$(item)' '$(srcdir)/$(item)')
htmlref_patterns_quote = $(patsubst %,'%',$(htmlref_patterns))
htmlref_patterns_vpath = $(if $(srcdir:.=),$(htmlref_patterns_dup),$(htmlref_patterns_quote))
htmlref_patterns_dup_static   = $(foreach item,$(htmlref_patterns_static),'$(item)' '$(srcdir)/$(item)')
htmlref_patterns_quote_static = $(patsubst %,'%',$(htmlref_patterns_static))
htmlref_patterns_vpath_static = $(if $(srcdir:.=),$(htmlref_patterns_dup_static),$(htmlref_patterns_quote_static))

# TODO: Use something standard instead of this mm-common thing.
doc_install ?= $(PERL) -- "$(MMDOCTOOLDIR)/doc-install.pl"
doc_install_cmd = $(doc_install) --verbose --mode=0644

# Install the HTML reference documentation files with just one invocation
# of doc-install.pl to speed up the build process.  Make use of the --glob
# option, which tells it to perform filename globbing itself, like 'find'.
# This helps to avoid excessively long command lines, as some platforms
# have rather restrictive limits.
# TODO: Install the stuff under _static.
install-htmlref: $(doc_outdir)/html/index.html html
	@$(NORMAL_INSTALL)
	$(MKDIR_P) '$(DESTDIR)$(htmlrefdir)'
	$(MKDIR_P) '$(DESTDIR)$(htmlrefdir)/_static'
	$(doc_install_cmd) -t '$(DESTDIR)$(htmlrefdir)' --glob -- $(htmlref_patterns_vpath)
	$(doc_install_cmd) -t '$(DESTDIR)$(htmlrefdir)/_static' --glob -- $(htmlref_patterns_vpath_static)

# Delete files from the html installation directory.  Avoid recursive
# directory removal, and apply the same wildcard pattern as was used to
# select files for installation.
uninstall-htmlref:
	@$(NORMAL_UNINSTALL)
	(cd '$(DESTDIR)$(htmlrefdir)' 2>/dev/null || exit 0; \
	 find . -type f '(' $(htmlref_find_patterns) ')' -exec rm -f '{}' '+')

# Define phony (non-file) targets so things don't break if anyone creates files with these names.
.PHONY: install-htmlref uninstall-htmlref

# Instruct GNU make to delete the targets of a rule after it failed, in
# order to avoid the complication of handling that situation manually.
.DELETE_ON_ERROR:
