
/* Generated data (by glib-mkenums) */

#include "enums.h"
/* Generated by glib-mkenums from "./libepc/dispatcher.h" */

#define __EPC_COLLISION_HANDLING_IS_ENUM__ 1

GType
epc_collision_handling_get_type (void)
{
  static GType etype = G_TYPE_INVALID;

  if (G_UNLIKELY (G_TYPE_INVALID == etype))
    {
      static const GEnumValue values[] =
        {
          { EPC_COLLISIONS_IGNORE, "EPC_COLLISIONS_IGNORE", "ignore" },
          { EPC_COLLISIONS_CHANGE_NAME, "EPC_COLLISIONS_CHANGE_NAME", "change-name" },
          { EPC_COLLISIONS_UNIQUE_SERVICE, "EPC_COLLISIONS_UNIQUE_SERVICE", "unique-service" },
          { 0, NULL, NULL }
        };

      etype = g_enum_register_static (g_intern_static_string ("EpcCollisionHandling"), values);
    }

  return etype;
}

/**
 * epc_collision_handling_get_class:
 *
 * Retrieves the GEnumClass describing the EpcCollisionHandling enum.
 *
 * Returns: The GEnumClass describing EpcCollisionHandling.
 */
GEnumClass*
epc_collision_handling_get_class (void)
{
  static GEnumClass *enum_class = NULL;

  if (G_UNLIKELY (NULL == enum_class))
    enum_class = g_type_class_ref (epc_collision_handling_get_type ());

  return enum_class;
}

#if __EPC_COLLISION_HANDLING_IS_ENUM__

/**
 * epc_collision_handling_to_string:
 * @value: a EpcCollisionHandling value
 *
 * Retrieves the name of a EpcCollisionHandling @value, or %NULL when @value is invalid.
 *
 * Returns: The string representation of @value, or %NULL.
 */
const gchar*
epc_collision_handling_to_string (EpcCollisionHandling value)
{
  const GEnumValue *enum_value = g_enum_get_value (epc_collision_handling_get_class (), value);

  g_return_val_if_fail (NULL != enum_value, NULL);
  return enum_value->value_name;
}

#endif
/* Generated by glib-mkenums from "./libepc/protocol.h" */

#define __EPC_PROTOCOL_IS_ENUM__ 1

GType
epc_protocol_get_type (void)
{
  static GType etype = G_TYPE_INVALID;

  if (G_UNLIKELY (G_TYPE_INVALID == etype))
    {
      static const GEnumValue values[] =
        {
          { EPC_PROTOCOL_UNKNOWN, "EPC_PROTOCOL_UNKNOWN", "unknown" },
          { EPC_PROTOCOL_HTTP, "EPC_PROTOCOL_HTTP", "http" },
          { EPC_PROTOCOL_HTTPS, "EPC_PROTOCOL_HTTPS", "https" },
          { 0, NULL, NULL }
        };

      etype = g_enum_register_static (g_intern_static_string ("EpcProtocol"), values);
    }

  return etype;
}

/**
 * epc_protocol_get_class:
 *
 * Retrieves the GEnumClass describing the EpcProtocol enum.
 *
 * Returns: The GEnumClass describing EpcProtocol.
 */
GEnumClass*
epc_protocol_get_class (void)
{
  static GEnumClass *enum_class = NULL;

  if (G_UNLIKELY (NULL == enum_class))
    enum_class = g_type_class_ref (epc_protocol_get_type ());

  return enum_class;
}

#if __EPC_PROTOCOL_IS_ENUM__

/**
 * epc_protocol_to_string:
 * @value: a EpcProtocol value
 *
 * Retrieves the name of a EpcProtocol @value, or %NULL when @value is invalid.
 *
 * Returns: The string representation of @value, or %NULL.
 */
const gchar*
epc_protocol_to_string (EpcProtocol value)
{
  const GEnumValue *enum_value = g_enum_get_value (epc_protocol_get_class (), value);

  g_return_val_if_fail (NULL != enum_value, NULL);
  return enum_value->value_name;
}

#endif
/* Generated by glib-mkenums from "./libepc/publisher.h" */

#define __EPC_AUTH_FLAGS_IS_FLAGS__ 1

GType
epc_auth_flags_get_type (void)
{
  static GType etype = G_TYPE_INVALID;

  if (G_UNLIKELY (G_TYPE_INVALID == etype))
    {
      static const GFlagsValue values[] =
        {
          { EPC_AUTH_DEFAULT, "EPC_AUTH_DEFAULT", "default" },
          { EPC_AUTH_PASSWORD_TEXT_NEEDED, "EPC_AUTH_PASSWORD_TEXT_NEEDED", "password-text-needed" },
          { 0, NULL, NULL }
        };

      etype = g_flags_register_static (g_intern_static_string ("EpcAuthFlags"), values);
    }

  return etype;
}

/**
 * epc_auth_flags_get_class:
 *
 * Retrieves the GFlagsClass describing the EpcAuthFlags flags.
 *
 * Returns: The GFlagsClass describing EpcAuthFlags.
 */
GFlagsClass*
epc_auth_flags_get_class (void)
{
  static GFlagsClass *flags_class = NULL;

  if (G_UNLIKELY (NULL == flags_class))
    flags_class = g_type_class_ref (epc_auth_flags_get_type ());

  return flags_class;
}

#if __EPC_AUTH_FLAGS_IS_ENUM__

/**
 * epc_auth_flags_to_string:
 * @value: a EpcAuthFlags value
 *
 * Retrieves the name of a EpcAuthFlags @value, or %NULL when @value is invalid.
 *
 * Returns: The string representation of @value, or %NULL.
 */
const gchar*
epc_auth_flags_to_string (EpcAuthFlags value)
{
  const GFlagsValue *flags_value = g_flags_get_value (epc_auth_flags_get_class (), value);

  g_return_val_if_fail (NULL != flags_value, NULL);
  return flags_value->value_name;
}

#endif
/* Generated by glib-mkenums from "./libepc/service-info.h" */

#define __EPC_ADDRESS_FAMILY_IS_ENUM__ 1

GType
epc_address_family_get_type (void)
{
  static GType etype = G_TYPE_INVALID;

  if (G_UNLIKELY (G_TYPE_INVALID == etype))
    {
      static const GEnumValue values[] =
        {
          { EPC_ADDRESS_UNSPEC, "EPC_ADDRESS_UNSPEC", "unspec" },
          { EPC_ADDRESS_IPV4, "EPC_ADDRESS_IPV4", "ipv4" },
          { EPC_ADDRESS_IPV6, "EPC_ADDRESS_IPV6", "ipv6" },
          { 0, NULL, NULL }
        };

      etype = g_enum_register_static (g_intern_static_string ("EpcAddressFamily"), values);
    }

  return etype;
}

/**
 * epc_address_family_get_class:
 *
 * Retrieves the GEnumClass describing the EpcAddressFamily enum.
 *
 * Returns: The GEnumClass describing EpcAddressFamily.
 */
GEnumClass*
epc_address_family_get_class (void)
{
  static GEnumClass *enum_class = NULL;

  if (G_UNLIKELY (NULL == enum_class))
    enum_class = g_type_class_ref (epc_address_family_get_type ());

  return enum_class;
}

#if __EPC_ADDRESS_FAMILY_IS_ENUM__

/**
 * epc_address_family_to_string:
 * @value: a EpcAddressFamily value
 *
 * Retrieves the name of a EpcAddressFamily @value, or %NULL when @value is invalid.
 *
 * Returns: The string representation of @value, or %NULL.
 */
const gchar*
epc_address_family_to_string (EpcAddressFamily value)
{
  const GEnumValue *enum_value = g_enum_get_value (epc_address_family_get_class (), value);

  g_return_val_if_fail (NULL != enum_value, NULL);
  return enum_value->value_name;
}

#endif

/* Generated data ends here */

